---
title: "[Dev] RealMatch - 브랜드 & 크리에이터 매칭 플랫폼"
slug: "real-match"
period: "2026.01.02 - 2026.02.20"
tech: ["Spring Boot", "JPA", "QueryDSL", "WebSocket", "RabbitMQ", "FCM", "Docker", "MySQL", "Redis", "GitHub Actions", "HAProxy", "Cloudflare", "CloudFront", "S3", "Prometheus", "Grafana", "React", "Vite", "TypeScript"]
images: ["https://eaalkymxyfskjojh.public.blob.vercel-storage.com/portfolio/real-match/real-match.png"]
summary: "UMC 9기 프로젝트 SpringBoot 백엔드 개발"
githubUrl: "https://github.com/RealMatchTeam"
siteUrl: "https://www.realmatch.co.kr"
category: "project"
categorizedTech: true
teamMembers: "PM 1명, 디자인 1명, 프론트엔드 4명, 백엔드 5명"
myRole: "실시간 WebSocket 채팅 서비스 구현, S3 파일 스토리지 구현, FCM 웹 푸시 알림 및 Spring Mail 이메일 알림 시스템 구현"
---

# 프로젝트 개요

![핵심 기능](https://eaalkymxyfskjojh.public.blob.vercel-storage.com/portfolio/real-match/core.png)

**RealMatch**는 브랜드와 마이크로 인플루언서가 협업 상대를 찾고 제안, 협의, 콘텐츠 제작, 피드백, 완료까지의 과정을 `하나의 흐름 안에서 관리할 수 있도록 설계한 협업 관리 플랫폼`입니다.

기존 인플루언서 협업은 메신저, 이메일, 문서가 분산되어 진행되며 협업 상태를 명확히 추적하기 어렵고 일정 누락이나 요구사항 전달 오류가 반복적으로 발생했습니다.

**RealMatch**는 협업 과정을 서비스 내부의 상태로 관리하여 단순 매칭 서비스가 아니라 실제 협업 운영을 지원하는 시스템으로 동작하도록 만드는 것을 목표로 했습니다.

&nbsp;

# 시스템 아키텍처 설계

![시스템 아키텍처](https://eaalkymxyfskjojh.public.blob.vercel-storage.com/portfolio/real-match/system-architecture.png)

### 프론트엔드 배포

프론트엔드는 Vercel에 배포해 정적 자산을 CDN으로 제공했습니다. 
프론트 배포를 백엔드 릴리즈와 분리하여, UI 변경을 더 빠르게 반영하고 
백엔드 배포 리스크에 영향을 받지 않도록 했습니다.

### 백엔드 인프라

백엔드는 `가비아 클라우드`에 배포했습니다. 사용자 트래픽은 **CloudFlare**를 
거쳐 HTTPS로 전달되고, 가비아 내부에서는 **HAProxy**가 리버스 프록시로 동작해 Spring Boot 
애플리케이션으로 라우팅합니다. 애플리케이션 VM과 DB VM을 분리해 Redis, RabbitMQ, MySQL을 
별도 컨테이너로 운영했습니다. 외부 노출 지점을 CloudFlare와 HAProxy로 최소화하고, 라우팅과 
접근 제어를 리버스 프록시 계층에서 일괄 통제할 수 있도록 구성했습니다.

### 배포 전략

배포는 GitHub Actions로 빌드 및 Docker 이미지 생성을 수행하고, Docker Hub에 푸시한 뒤 
가비아 클라우드 VM에서 최신 이미지를 반영하는 방식으로 구성했습니다. CI/CD 파이프라인을 통해 
코드 푸시부터 배포까지 자동화했고, 컨테이너 단위 배포로 환경 일관성을 유지했습니다.

### 파일 스토리지 및 CDN

파일 스토리지는 S3를 사용했고, 용도에 따라 퍼블릭 버킷과 프라이빗 버킷을 분리했습니다. 
퍼블릭 버킷은 **CloudFront**와 연동해 CDN으로 제공하고, 프라이빗 버킷은 Presigned URL로 
제한된 접근만 허용하도록 구성했습니다.

### Firebase Cloud Messaging

**FCM**을 사용해 오프라인 사용자에게도 협업 이벤트를 전달할 수 있도록 했습니다. 
Spring Boot 애플리케이션에서 FCM API를 호출해 웹 푸시를 발송합니다.

&nbsp;

# 실시간 WebSocket 채팅 시스템

![채팅 시스템](https://eaalkymxyfskjojh.public.blob.vercel-storage.com/portfolio/real-match/chat.png)

**RealMatch**의 채팅은 단순 대화 기능이 아니라 협업 진행을 위한 주요 인터페이스입니다.
브랜드와 크리에이터는 제안 발송, 지원 요청, 매칭 완료 이후 일정·요구사항·피드백을 채팅을 통해 조율하며, 협업 상태 또한 동일 채널에서 시스템 메시지로 전달됩니다.

STOMP의 구독 모델을 이용해 채팅방 단위로 메시지를 브로드캐스트하도록 구성했고, 
인증 인터셉터를 적용해 연결 시점부터 사용자 검증이 가능하도록 했습니다.

채팅 메시지는 휘발성 데이터가 아니라 협업 기록이므로 DB에 영속화하고, 재접속 시 REST 
조회로 복구할 수 있도록 설계했습니다. 이를 통해 WebSocket 연결이 끊겨도 대화 상태가 
유지되도록 했습니다.

`시스템 메시지`는 비즈니스 로직의 결과로 생성되기 때문에, 채팅 모듈이 비즈니스 로직을 
직접 호출하면 강한 결합이 발생하고, 반대로 비즈니스 로직에서 채팅을 직접 호출하면 트랜잭션 
경계가 모호해질 수 있었습니다.

### AS-IS

채팅에는 제안·지원·매칭 결과를 안내하는 시스템 메시지가 포함됩니다. 
이 메시지를 비즈니스 트랜잭션과 같은 흐름에서 전송할 경우, 상태 변경이 실패하더라도 
사용자에게 메시지가 이미 전달되는 불일치가 발생했습니다. 또한 이벤트가 재처리되거나 
중복 처리될 경우 동일 제안 카드가 여러 번 표시될 수 있었습니다. 
채팅 메시지는 단순 UI 데이터가 아니라 비즈니스 상태를 표현하는 정보이므로, 
데이터 확정 이전에 전달되면 실제로 확정되지 않은 협업 상태가 사용자에게 노출되는 구조였습니다.

### TO-BE

채팅과 비즈니스 로직을 직접 연결하지 않고 도메인 이벤트 기반으로 분리했습니다. 
비즈니스 트랜잭션이 커밋된 이후에만 이벤트를 발행하고, 채팅 모듈이 이를 구독해 
시스템 메시지를 생성·전송하도록 변경했습니다.

`@TransactionalEventListener(phase = AFTER_COMMIT)`을 사용해 상태가 확정된 경우에만 시스템 메시지를 생성하도록 했고, Redis 기반 멱등성 키로 동일 이벤트 중복 처리를 제어했습니다. 
또한 메시지 처리 실패는 DLQ로 분리해 추적 가능하도록 구성했습니다.

추가로 마지막 메시지 시간과 읽음 처리 갱신을 조건부 UPDATE 방식으로 수정해 동시 전송 상황에서도 채팅 목록 정렬이 깨지지 않도록 했습니다.

&nbsp;

# S3 파일 스토리지

### AS-IS

파일 업로드는 데이터베이스 트랜잭션에 참여하지 않는 외부 작업입니다.
업로드와 DB 저장을 하나의 흐름으로 처리하면 두 결과가 어긋날 수 있습니다. 
업로드 후 DB 저장이 실패하면 스토리지에는 파일이 남지만 시스템에서는 존재하지 않는 
고아 파일이 되고, 반대로 DB 저장 후 업로드가 실패하면 시스템에는 파일이 존재하지만 
실제 데이터는 없는 상태가 됩니다.

또한 업로드를 트랜잭션 내부에서 수행할 경우 업로드 지연 동안 데이터베이스 커넥션이 
점유되어 다른 요청의 처리 지연이나 커넥션 풀 고갈로 이어질 수 있습니다.

### TO-BE

파일 저장을 단일 작업이 아니라 단계적인 상태 전이로 설계했습니다.
먼저 파일의 메타데이터만 데이터베이스에 기록한 뒤, 스토리지 업로드는 트랜잭션 외부에서 
수행하도록 분리했습니다. 업로드가 성공하면 파일을 사용 가능한 상태로 전환하고, 
실패하면 실패 상태로 남겨 정리 대상이 되도록 했습니다. 이를 통해 데이터베이스와 
스토리지 사이의 정합성을 유지하면서도 업로드 지연이 트랜잭션에 영향을 주지 않도록 했습니다.

또한 파일의 사용 목적에 따라 `접근 정책을 구분`했습니다. 채팅 첨부파일은 인증된 사용자만 
접근할 수 있도록 제한 URL 방식으로 제공하고, 브랜드 이미지와 캠페인 이미지는 CDN을 통해 
공개적으로 제공하도록 구성했습니다. 업로드 시에는 경로 조작 공격을 방지하고 파일 타입과 
크기를 검증해 보안을 확보했습니다.

주기적인 정리 작업을 통해 업로드가 완료되지 않은 파일이나 실패 상태로 남은 파일을 
자동으로 제거해 장기적인 스토리지 누적 문제를 방지했습니다.

&nbsp;

# FCM 푸시 & 이메일 알림

**RealMatch**는 협업 매칭 플랫폼 특성상 사용자가 항상 서비스에 접속해 있는 상태가 아닙니다. 
제안 수신, 지원 요청, 매칭 완료는 즉시 대응이 필요한 이벤트이지만, 
사용자는 브라우저를 닫은 상태이거나 로그인하지 않은 경우가 더 많았습니다.

SSE나 WebSocket 기반 알림은 세션이 유지된 상태에서만 전달 가능하기 때문에, 
오프라인 상태의 사용자에게 이벤트를 전달할 수 없었습니다. 따라서 알림은 페이지 
내부 알림이 아니라 서비스 외부까지 전달되는 알림 채널이 필요했고, 브라우저가 종료된 
상태에서도 전달 가능한 `Web Push 기반의 FCM`을 사용했습니다. 이메일은 장기 미확인 
사용자에 대한 보조 채널로 함께 구성했습니다.


### AS-IS

초기 구조에서는 협업 상태 변경 시 애플리케이션 요청 흐름 안에서 바로 FCM과 이메일 발송을 수행했습니다.
문제는 외부 네트워크 호출이 데이터베이스 트랜잭션과 동일한 흐름에서 실행된다는 점이었습니다.

외부 호출이 포함되면서 요청 처리 시간이 길어졌고, 트랜잭션이 실패해 롤백되더라도 
이미 사용자에게 알림이 전달될 수 있었습니다. 즉 실제 상태 변경은 실패했는데 사용자에게는 
매칭 완료 알림이 전달되는, 시스템 상태와 사용자 인지가 어긋날 수 있는 구조였습니다.

또한 일시적인 네트워크 오류가 발생하면 발송 실패를 안정적으로 복구할 방법이 없어 알림 
유실 가능성도 존재했습니다.

### TO-BE

알림 전송을 요청 처리 흐름에서 분리하기 위해 `Outbox 패턴과 메시지 큐(RabbitMQ)`를 적용했습니다.

비즈니스 트랜잭션에서는 알림을 직접 발송하지 않고 전달해야 할 이벤트만 함께 기록하도록 했습니다. 
트랜잭션이 정상적으로 커밋된 이후 별도의 전달 프로세스가 해당 이벤트를 메시지 큐로 발행하고, 
실제 FCM 및 이메일 발송은 큐를 구독하는 소비자 프로세스에서 수행하도록 구조를 변경했습니다.

이렇게 구조를 나누면서 상태 변경이 실패하면 알림 자체가 생성되지 않도록 만들 수 있었고, 
반대로 외부 네트워크 지연이나 FCM 응답 시간 때문에 사용자 요청이 느려지는 문제도 사라졌습니다. 
또한 발송 과정에서 오류가 발생하더라도 이벤트가 큐에 남아 재처리될 수 있어 알림 유실 가능성을 
줄일 수 있었습니다. 다중 인스턴스 환경에서도 알림이 한 번만 전달되도록 제어할 수 있었고, 
실패한 메시지는 별도로 추적해 복구할 수 있게 했습니다.

&nbsp;

# 소소한 이야기
https://www.1000hyehyang.me/blog/D_kwDOPOCJ884AkQhw